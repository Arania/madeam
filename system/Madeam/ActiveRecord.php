<?php
/**
 * Madeam :  Rapid Development MVC Framework <http://www.madeam.com/>
 * Copyright (c)	2006, Joshua Davey
 *								24 Ridley Gardens, Toronto, Ontario, Canada
 *
 * Licensed under The MIT License
 * Redistributions of files must retain the above copyright notice.
 *
 * @copyright		Copyright (c) 2006, Joshua Davey
 * @link				http://www.madeam.com
 * @package			madeam
 * @license			http://www.opensource.org/licenses/mit-license.php The MIT License
 */
class Madeam_ActiveRecord extends Madeam_Model {
  protected $label                = null;     // name of field that acts as label for a row

  protected $conn                 = false;    // connection resource

  protected $data                 = array();
  protected $entry                = array();  // represents a single row
  protected $sql                  = null;
  protected $link                 = null;     // query resource link
  protected $entryId              = -1;       // row id

	protected $isInsert						  = false;
	protected $isUpdate						  = false;

	protected $server               = 0; // the name of the server configuration we want to use.

  private $_sqlExplain            = false;
  private $_sqlStart              = false;
  private $_sqlFields							= array();
  private $_sqlRange              = false;
  private $_sqlOrder              = false;
  private $_sqlWhere              = '1';
  private $_sqlJoins              = array();
  private $_sqlGroup              = false;
  private $_sqlHaving             = false;

  /**
   * Magic method allows for special query functions like findAll_by_name('Joshua');
   *
   * @param string $name
   * @param array $args
   * @return array/boolean
   */
  public function __call($name, $args) {
    $match = array();
    if (preg_match("/^find_([a-z]+)_by_(.*)/", $name, $match)) {
      $this->where($match[2] . " = '$args[0]'");
      $function = 'find_' . $match[1];
      return $this->$function();
    } /*elseif (preg_match("/^delete_by_(.*)/", $name, $match)) {
      $this->where($match[2] . " = '$args[0]'");
      $this->delete();
    }*/
    
    return false;
  }

  /**
   * Query Methods
   * =======================================================================
   */

  /**
   * Enter description here...
   *
   * @param string $sql
   * @return resource
   */
  final public function execute($sql) {
    global $db_connection; // this is the only good use of globals. But still I wish we could get rid of the global part

    // if we connect here we don't need to connect to the database until we execute a query
    // therefore if all we're doing is loading a cached page we won't need a database connection
    if (!is_resource($db_connection)) {

      // parse DB information
      $config = Madeam_Registry::get('config');
      $servers = $config['data_servers'];
      $server_connection_string = $servers[$this->server];

      $server = $this->parseDbConnection($server_connection_string);

      if (isset($server['port']) && $server['port'] != false) {
        $db_connection = mysql_connect($server['host'] . ':' . $server['port'], $server['user'], $server['pass']);
      } else {
        $db_connection = mysql_connect($server['host'], $server['user'], $server['pass']);
      }

      if (is_resource($db_connection)) {
        if (!@mysql_select_db($server['name'], $db_connection)) {
          // failed to find selected database
          madeam_logger::log(mysql_error(), 0);
        }
      } else {
        // failed to connect to the database
        madeam_logger::log(mysql_error(), 0);
      }
    }

    // execute mysql query
    $this->link = mysql_query($sql);

    // log query
    madeam_logger::log($sql, 100);

    // log sql error if any
    if (mysql_error()) {
      madeam_logger::log(mysql_error());
    }

    return $this->link;
  }

	final public function query($sql) {
	  // execute query
		$this->link =	$this->execute($sql);

		// check to see if this query returns a resource -- why not just check to see if it's a resource instead?
		$matchs = array();
		preg_match('/^DESCRIBE|SELECT/', $sql, $matchs);

		if (count($matchs) > 0) {
		  if ($this->numRows() > 0) {
  			while ($this->entry = mysql_fetch_assoc($this->link)) {
  			  // don't prepare results of describe queries
  			  if ($matchs[0] != "DESCRIBE" && $matchs[0] != 'describe') {
  		      $this->prepareResult(); // should this be done?
  			  }
  				$this->data[] = $this->entry;
  			}
  			return $this->data;
		  } else {
		    return array(); // return empty data
		  }
		} else {
		  return $this->link;
		}
	}

	final public function describe() {
	  $table = $this->setup['resource_name'];
	  return $this->query("DESCRIBE $table");
	}

  /**
   * Returns many rows. The query generated by findAll can be tweaked with the methods below
   * @see where()
   * @see limit()
   * @see order()
   * @see fields()
   *
   * @return array/boolean
   */
  final public function find() {
    $this->data = array();

    // find callback
    $this->beforeFind();

    // if this is a child model then filter the results to make sure they are related to this model's parent
    // this stuff is for when chaining models like:
    // $this->article->findOne(32, true)->comment->findAll();
    // where article is the parent of comment
    if ($this->parent && $this->_sqlWhere == '1') {
      $this->where($this->parent->setup['has_models'][$this->name]['foreign_key'] . " = '" . $this->parent->entry[$this->parent->setup['has_models'][$this->name]['primary_key']] . "'");
      //$this->where($this->parent->setup['has_models'][$this->name]['foreign_key'] . " = '" . $this->parent->setup['has_models'][$this->name]['primary_key'] . "'");
    }

    // build select query and set resource link
    $this->link = $this->execute($this->buildQuerySelect());

    if (is_resource($this->link)) {
      // get data
      while ($this->entry = mysql_fetch_assoc($this->link)) {
        // adds custom fields
        $this->prepareResult();

        // find related content
        if ($this->depth > 0) {
          // find has_ones
          foreach ($this->setup['has_one'] as $model => $params) {
            $fkey = $params['foreign_key'];
            if (!in_array($model, array_values($this->unbound)) && !in_array($model, array_keys($this->_sqlJoins))) {
              // we need to solve for the foreign key name some where here instead of assuming it'll always be named after the table
              // clone object so we don't interupt it's state with reset()

              $tempmodel = clone $this->{$params['model']};
              $tempmodel->name = $model;

              $this->entry[$params['foreign_key']] = $tempmodel->findOne($this->entry[$fkey]);
              unset($tempmodel);
            }
          }

          // find belongs_tos
          foreach ($this->setup['belongs_to'] as $model => $params) {
            $fkey = $params['foreign_key'];
            if (!in_array($model, array_values($this->unbound)) && !in_array($model, array_keys($this->_sqlJoins))) {
              // we need to solve for the foreign key name some where here instead of assuming it'll always be named after the table
              // clone object so we don't interupt it's state with reset()

              $tempmodel = clone $this->{$params['model']};
              // change the model name because we can't always assume that the name will be the same.
              // An example of this is when you create a self-refrencing relationship in a table and name the relationship "sub_model" or "parent_model"
              $tempmodel->name = $model;

              @$this->entry[$params['foreign_key']] = $tempmodel->findOne($this->entry[$fkey]);
              unset($tempmodel);
            }
          }

          // find has_manies
          foreach ($this->setup['has_many'] as $model => $params) {
            // do not call if the user has not specified to call this data
            if (!in_array($model, array_values($this->unbound)) && !in_array($model, array_keys($this->_sqlJoins))) {
              // clone object so we don't interupt it's state with reset()
              $tempmodel = clone $this->{$params['model']};
              $tempmodel->name = $model;

              $this->entry[madeam_inflector::model_tableize($model)] = $tempmodel->findAll();
              unset($tempmodel);
            }
          }

          // find has and belongs to manies
          foreach ($this->setup['has_and_belongs_to_many'] as $model => $params) {
            if ((in_array($model,$this->fields) || empty($this->fields)) && !in_array($model, array_values($this->unbound)) && !in_array($model, array_keys($this->_sqlJoins))) {
              $tempmodel = clone $this->{$params['model']};
              $tempmodel->name = $model;

              $this->entry[madeam_inflector::model_tableize($params['model'])] = $tempmodel
                ->join($this->name)
                ->findAll();

              unset($tempmodel);
            }
          }

        }

        $this->data[] = $this->entry;
      }
    }


    // find callback
    $this->afterFind();

    // return data
    if ($this->numRows() > 0) {
      // grab data before it's reset
      $data = $this->data;

      // reset all sql values and data
      $this->reset();

      return $data;
    }

    // reset all sql values and data
    $this->reset();

    // failed to return any rows
    return false;
  }

  /**
   * synonym for find()
   * @see find()
   * @return array/boolean
   */
  final public function findAll() {
    return $this->find();
  }

  /**
   * This is findAll except that it returns a list
   * @see find
   * @param string $value
   * @param string $label
   * @return array/boolean
   */
  final public function findList($value, $label = false) {
    if ($results = $this->find()) {
      return $this->generateList($results, $value, $label);
    }
    return false;
  }

  /**
   * This turns any result into a list
   *
   * @param array $result
   * @param string $value
   * @param string $label
   * @return unknown
   */
  final public function generateList($result, $value, $label = false) {
    if ($value != null) {
      $list = array();

      if ($label == false) {
        // non-labeled list
        foreach ($result as $item) {
          $list[] = $item[$value];
        }
      } else {
        // labeled list
        foreach ($result as $item) {
          $list[] = array($item[$label], $item[$value]);
        }
      }

      return $list;
    }

    return false;
  }

  /**
   * Find a single row based on value of primary_key
   *
   * @param string/int $id
   * @return array/false
   */
  final public function findOne($id = -1, $chain = false) {
    $this->entry = array();

    // set entryId
    if ($id != -1) { $this->entryId = $id; }

    // set where
    if ($this->entryId != -1 && $this->primary_key != false) {
      $table = $this->setup['resource_name'];
      $this->where("$table.$this->primary_key = '$id'");
    }

    // set limit
    $this->limit(1);

    // find stuff!
    $this->data = $this->find();
    $this->entry = $this->data[0];

    if ($chain) {
      // return object because this entry is being chained
      return $this;
    } else {
      return $this->entry;
    }
  }

  /**
   * Deletes a record in the database by Primary Key value
   *
   * @param integer/string $id
   */
  final public function delete($id = -1) {
    // reset all sql values and data
    $this->reset();

    // validation callbacks
    $this->before_validation();
    $this->after_validation();

    // before delete callback
    $this->beforeDelete();

    if ($id != -1) { $this->entryId = $id; }
    $this->execute($this->buildQueryDelete());

    // after delete callback
    $this->afterDelete();

    // check success
    if ($this->affectedRows() > 0) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * Creates/Updates a record in the database
   *
   * An update is assumed if the primary_key has a value
   *
   * @param array $data
   */
  final public function save($data) {
    // true/false
    $update = false;

    // set $this->entry so it is accessible in callbacks
    $this->entry = $data;

    // set entryId
    if (isset($this->entry[$this->primary_key]) && $this->entry[$this->primary_key] != null) {
      $this->entryId = $this->entry[$this->primary_key];
    }

    // check to see whether this is going to be an insert or an update
    $name = get_class($this);
    $inst = new $name;

    // if the entryId exists and the record exists then it is an update. Otherwise it's an insert
    if ($this->entryId != -1 && $inst->findOne($this->entryId)) {
      $update = true;
    }

    // unset duplicate of this model to save on sweet sweet memory
    unset($inst);

    // before validation callback
    $this->before_validation();

    // validate data
    ////$this->load_validators();
    $this->validate_entry($update);

    // after validation callback
    $this->after_validation();

    // now that all the callbacks prior to updating/adding the new row have been called
    // we must check for any errors that may have been envoked.
    // if there aren't any then continue as usual.
    // if not then skip adding/updating
    if (!isset($_SESSION[USER_ERROR_NAME]) || count($_SESSION[USER_ERROR_NAME]) < 1) {
      // do standard field formats
      $this->standardFieldFormats();

      // before save callback
      $this->beforeSave();

      /*
      // relations
      $relations = array();

      // determine if any of the fields represents any of this model's relationships
      foreach ($this->entry as $field => $value) {
        if (is_array($value)) {
          $relations[$field] = $value;

          // instead of just unsetting it, it should get it's primary_key value!
          $this->entry[$field] = $value[$this->{madeam_inflector::model_nameize($field)}->primary_key];
        }
      }
      */

      // set data as row after callbacks have altered $this->entry
      $this->data = $this->entry;

      // filter out fields that don't exist in the model
      $this->data = array_intersect_key($this->data, array_flip($this->setup['standard_fields']));

      // if the entryId exists and the record exists then it is an update. Otherwise it's an insert
      if ($update === true) {
				$this->isUpdate = true; // can be used by the dev to figure out if it's an insert or update when using callbacks
        $this->execute($this->buildQueryUpdate());
      } else {
				$this->isInsert = true; // can be used by the dev to figure out if it's an insert or update when using callbacks
        $this->execute($this->buildQueryInsert());
      }

      // grab entry id before it's overwritten by something that happens in afterSave()
      $entryId = $this->insert_id();

			// set this so it can be used in afterSave
			$this->entry[$this->primary_key] = $entryId;

			// grab entry after it's been modified by callbacks
			$entry = $this->entry;

      /*
      if ($entryId) {
        // check for fields that are arrays
        foreach ($relations as $model => $value) {
          $model = madeam_inflector::model_nameize($model);
          if (in_array($model, array_keys($this->setup['has_and_belongs_to_many']))) {
            $this->habtmAdd($model, $entryId, $value);
          } else {
            $this->$model->save($value);
          }
        }
      }
      */

      // after save callback
      $this->afterSave();

      // reset all sql values and data
      $this->reset();

      return $entry;
    } else {
      // reset all sql values and data
      $this->reset();

      return false;
    }

    // reset all sql values and data
    $this->reset();

    // return data
    if ($this->affectedRows() > 0) { return $this->data; }

    // failed to return any rows
    return false;
  }

  final public function habtmAdd($model, $id, $assoc = array()) {
    if (!is_array($assoc)) { $assoc = array($assoc); }

    // clone current class just because...
    // this is not cool though because this means shit is going to be validated when it shouldn't be.
    // do we need to call beforeSave and all the other callbacks or just not worry about it?
    $class = clone $this;

    // set table name
    $class->resourceName = madeam_inflector::model_habtm($model, $this->name);
    $class->primary_key = false;

    $this_key = madeam_inflector::model_foreign_key($this->name);
    $relation_key = madeam_inflector::model_foreign_key($model);

    //$this->ItemStore->findOne(1,2);

    foreach ($assoc as $val) {
      // check for duplicate
      $class->where("$this_key = '$id' AND $relation_key = '$val'")->unbind_all()->findOne();
      if ($class->numRows() < 1) {
        $class->data = array($this_key => $id, $relation_key => $val);
        $class->execute($class->buildQueryInsert());
      }
    }

    unset($class);
  }


  final public function habtmDelete($model, $id, $assoc = array()) {
    if (!is_array($assoc)) { $assoc = array($assoc); }

    // clone current class just because...
    // this is not cool though because this means shit is going to be validated when it shouldn't be.
    // do we need to call beforeSave and all the other callbacks or just not worry about it?
    $class = clone $this;

    // set table name
    $class->resource_name = madeam_inflector::model_habtm($model, $this->name);
    $class->primary_key = false;

    $this_key = madeam_inflector::model_foreign_key($this->name);
    $relation_key = madeam_inflector::model_foreign_key($model);

    foreach ($assoc as $val) {
      $class->data = array($this_key => $id, $relation_key => $val);
      $class->where("$this_key = '$id' AND $relation_key = '$val'");
      $class->execute($class->buildQueryDelete());
    }

    unset($class);
  }


 	final public function increase($id, $field, $amount = 1) {
		if ($record =$this->fields($field, $this->primary_key)->findOne($id)) {
			$record[$field] = $record[$field] + $amount;
			if ($this->save($record)) {
				return true;
			}
		}

		return false;
	}

	final public function decrease($id, $field, $amount = 1) {
		if ($record =$this->fields($field, $this->primary_key)->findOne($id)) {
			$record[$field] = $record[$field] - $amount;
			if ($this->save($record)) {
				return true;
			}
		}

		return false;
	}


  /**
   * Creates table
   * Soon this method will have migration abilities but for now it just creates tables...
   */
  final public function migrate($drop = false) {
    $sql      = array(); // our query in array form -- soon to be imploded
    $uniques  = array(); // list of fields that have unique values

    // drop table -- this doesn't work yet
    if ($drop == true) {
      $sql[] = 'DROP TABLE IF EXISTS `' . $this->setup['resource_name'] . "`; \n";
    }

    // initial query decleration
    $sql[] = 'CREATE TABLE IF NOT EXISTS `' . $this->setup['resource_name'] . '` (';

    // add fields
    $fields = array();
    foreach ($this->schema as $name => $opts) {
      $field = array();

      // Field type
      if (!empty($opts['values'])) {
        // values (enum and set)
        $field[] = "`$name` $opts[type]('" . implode("','", $opts['values']) . "')";
      } elseif ($opts['size'] != null) {
        // size
        $field[] = "`$name` $opts[type]($opts[size])";
      } else {
        // neither
        $field[] = "`$name` $opts[type]";
      }

      // NULL?
      if ($opts['null'] == false) {
        $field[] = 'NOT NULL';
      } else {
        $field[] = 'NULL';
      }

      // default value
      if ($opts['default'] != null) {
        $field[] = "DEFAULT '$opts[default]'";
      }

      // auto increment
      if (in_array('auto_increment', $opts)) {
        $field[] = 'AUTO_INCREMENT';
      }

      // primary key
      if (in_array('primary_key', $opts)) {
        $field[] = 'PRIMARY KEY';
      }

      // unique
      if (in_array('unique', $opts)) {
        $uniques[] = $name;
      }

      // add to list of fields
      $fields[] = implode(' ', $field);
    }

    // add fields
    $sql[] = implode(", ", $fields);

    // add uniques
    if (!empty($uniques)) {
      $sql[] = 'UNIQUE (`' . implode('`,`', $uniques) . '`)';
    }

    // close
    $sql[] = ')';

    // create query string
    $sql = implode(' ', $sql);

    // create table
    $this->execute($sql);

    return true;
  }



  /**
   * Query Builders
   * =======================================================================
   */

  /**
   * Create Select Query
   *
   * @return string
   */
  final private function buildQuerySelect() {
    $sql = array();
    $table = $this->setup['resource_name'];

    if (empty($this->fields)) {
      if ($this->primary_key != false) {
        // why should we have to re-state the id? This is a hack! (only for JOINS)
        $sql[] = "SELECT *, $table.$this->primary_key as $this->primary_key FROM $table";
      } else {
        $sql[] = "SELECT * FROM $table";
      }
    } else {
      // select only sepcified fields
      $sql[] = "SELECT" ;

      // determine sql fields versus custom fields
      $fields =$this->_sqlFields;

      $sql[] = implode(",", $fields);
      $sql[] = "FROM $table";
    }

    // joins
    if (!empty($this->_sqlJoins)) {
      foreach ($this->_sqlJoins as $join) {
        $sql[] = "LEFT JOIN";
        $sql[] = $join['table'];
        $sql[] = 'ON ' . $join['on'];
      }
    }

    // add where
    $sql[] = 'WHERE ' . $this->_sqlWhere;

    // add order
    if ($this->_sqlOrder) {
      $sql[] = 'ORDER BY ' . $this->_sqlOrder;
    }

    // add limit
    if ($this->_sqlStart !== false && $this->_sqlRange !== false) {
      $sql[] = "LIMIT $this->_sqlStart, $this->_sqlRange";
    } elseif ($this->_sqlStart !== false && $this->_sqlRange === false) {
      $sql[] = "LIMIT $this->_sqlStart";
    }

    return implode(' ', $sql) . ';';
  }

  /**
   * Create Insert Query
   *
   * @return string
   */
  final private function buildQueryInsert() {
    $sql = array();
    $table = $this->setup['resource_name'];

    // remove primary key insert if it is null
    if (!isset($this->data[$this->primary_key]) || $this->data[$this->primary_key] == null) {
      unset($this->data[$this->primary_key]);
    }

    // add table name
    $sql[] = 'INSERT INTO ' . $table;

    // add fields
    $sql[] = '(' . implode(',', array_keys($this->data)) . ')';

    // close fields, open values
    $sql[] = 'VALUES';

    // add values
    $sql[] = "('" . @implode("','", array_values($this->data)) . "')";


    // build query
    //test(implode(' ', $sql));
    return implode(' ', $sql) . ';';
  }

  /**
   * Create Update Query
   *
   * @return string
   */
  final private function buildQueryUpdate() {
    $sql = array();
    $table = $this->setup['resource_name'];

    // add table name
    $sql[] = 'UPDATE ' . $table . ' SET';

    // fields
    if (empty($this->fields)) {
      $sets = array();
      foreach ($this->data as $field => $value) {
        $sets[] = "$field = '$value'"; // hack! what about SQL functions and Integers?
      }
    } else {
      foreach ($this->fields as $field) {
        $sets[] = "$field = '$this->data[$field]"; // hack! what about SQL functions and Integers?
      }
    }


    // add fields
    $sql[] = implode(", \n", $sets);

    // add where condition
    if ($this->_sqlWhere != 1) {
      $sql[] = 'WHERE ' . $this->_sqlWhere;
    } elseif ($this->entryId != -1) {
      if (is_int($this->entryId)) {
        $sql[] = 'WHERE ' . $this->primary_key . ' = ' . $this->entryId;
      } else {
        $sql[] = 'WHERE ' . $this->primary_key . ' = \'' . $this->entryId . '\'';
      }
    } else {
      return false;
    }

    // add limit
    if ($this->_sqlStart && $this->_sqlRange) {
      $sql[] = "LIMIT $this->start, $this->_sqlRange";
    } elseif ($this->_sqlStart && !$this->_sqlRange) {
      $sql[] = "LIMIT $this->_sqlStart";
    } else {
      $sql[] = 'LIMIT 1';
    }

    // build query
    //test(implode(' ', $sql));
    return implode(' ', $sql) . ';';
  }

  /**
   * Create Delete Query
   *
   * @return string
   */
  final private function buildQueryDelete() {
    $sql = array();

    // add table name
    $sql[] = 'DELETE FROM ' . $this->setup['resource_name'];

    // add where condition
    if ($this->_sqlWhere != 1) {
      $sql[] = 'WHERE ' . $this->_sqlWhere;
    } elseif ($this->entryId != -1) {
      if (is_int($this->entryId)) {
        $sql[] = 'WHERE ' . $this->primary_key . ' = ' . $this->entryId;
      } else {
        $sql[] = 'WHERE ' . $this->primary_key . ' = \'' . $this->entryId . '\'';
      }
    } else {
      return false;
    }

    // add limit
    if ($this->_sqlStart && $this->_sqlRange) {
      $sql[] = "LIMIT $this->start, $this->_sqlRange";
    } elseif ($this->_sqlStart && !$this->_sqlRange) {
      $sql[] = "LIMIT $this->_sqlStart";
    } else {
      $sql[] = 'LIMIT 1';
    }

    //test(implode(' ', $sql));
    return implode(' ', $sql) . ';';
  }

  /**
   * Query Modifiers
   * =======================================================================
   */

  /**
   * Appends WHERE clauses to the WHERE statement
   *
   * @param string $conditions
   */
  final public function where($conditions) {
    if ($this->_sqlWhere != 1) {
      // if a WHERE statement already exists then the new statement is appended to the old with an AND operator
      $this->_sqlWhere .= ' AND (' . $conditions . ')';
    } else {
      // otherwise a new condition is added and replaces the default of "1"
      $this->_sqlWhere = '(' . $conditions . ')';
    }

    // idea -- method chaining is crazy cool
    return $this;
  }

  final public function in($field, $values) {

    if (!empty($values)) {
      $sql = "$field IN ('" . implode("','", $values) . "')";

      $this->where($sql);
    }

    return $this;
  }

  /**
   * Set the order of the sql query
   *
   * @param string $order
   */
  final public function order($order) {
    $this->_sqlOrder = $order;

    // idea -- method chaining is crazy cool
    return $this;
  }

  /**
   * Set limit of query
   *
   * @param int $start
   * @param int $range
   */
  final public function limit($start, $range = false) {
    $this->_sqlStart = $start;
    $this->_sqlRange = $range;

    // idea -- method chaining is crazy cool
    return $this;
  }

  /**
   * Sets the fields to be selected, automatically includes primary_key
   *
   * @param list $fields
   */
  final public function fields() {

    foreach(func_get_args() as $field) {
      if (in_array($field, $this->setup['standard_fields'])) {
	    	$this->_sqlFields[] = $field;
  		}

  		$this->fields[] = $field;
    }

    // make sure there are no dupes
    $this->fields = array_unique($this->fields);

    return $this;
  }

  /**
   * Set the depth at which the active_record will search for relationships
   *
   * @param int $size
   */
  final public function depth($size) {
    $this->depth = $size;

    return $this;
  }

  /**
   * A switch to describe this query
   *
   * @param boolean $explain
   */
  final public function explain($explain = true) {
    $this->_sqlExplain = $explain;

    return $this;
  }

  final public function join($model, $on = false) {

    $model = madeam_inflector::model_nameize($model);
    $table = $this->setup['resource_name'];

    if ($on == false) {
      if (in_array($model, array_keys($this->setup['has_and_belongs_to_many']))) {

        $relation = $this->setup['has_and_belongs_to_many'][$model];

        $on = "$table.$this->primary_key = $relation[join_model].$relation[foreign_key]";

        $this->_sqlJoins[$model] = array('table' => $relation['join_model'], 'on' => $on);

      } elseif (in_array($model, array_keys(array_merge($this->setup['has_one'], $this->setup['has_many'], $this->setup['belongs_to'])))) {

        $fk = $this->setup['has_models'][$model]['foreign_key'];

        // I wish there was a better way to do this...
        // make the user type in more info?
        $foreign_table  = $this->$model->resource_name;
        $foreign_pk     = $this->$model->primary_key;

        $on = "$table.$fk = $foreign_table.$foreign_pk";

        $this->_sqlJoins[$model] = array('table' => $this->$model->resource_name, 'on' => $on);
      } else {
        t('this feature needs to be fixed - activeRecord join');
        $this->_sqlJoins[$model] = array('table' => $model, 'on' => $on);
      }
    } else {
      $this->_sqlJoins[$model] = array('table' => $this->$model->resource_name, 'on' => $on);
    }

    return $this;
  }

  /**
   * Resets all the sql values and data
   */
  final public function reset() {
    $this->_sqlWhere      = '1';
    $this->_sqlOrder      = false;
    $this->_sqlStart      = false;
    $this->_sqlRange      = false;
    $this->_sqlExplain    = false;
    $this->_sqlGroup      = false;
    $this->_sqlFields     = array();
    $this->_sqlJoins      = array();
    $this->fields         = array();
    $this->data           = array();
    $this->entry          = array();
    $this->entryId       = -1;
		$this->depth					= 2;

		$this->isInsert			= false;
		$this->isUpdate			= false;
    //$this->link           = false;

    // reset child models
    // this is so we can do stuff like...
    // $this->article->comment->depth(2)->fields('id', 'title');
    // $article = $this->article->findOne(32);
    // which will return an article with all of it's comments defined by it's sql modifiers like depth() and fields() and others
    foreach ($this->setup['has_models'] as $model => $info) {
      if (isset($this->$model)) {
        $this->$model->reset();
      }
    }
  }

  /**
   * Query Information
   * =======================================================================
   */


  /**
   * Gets ID of last row inserted
   *
   * @return integer
   */
  final public function insertId() {
    // this is necessary when the programmer has to specify a primary_key value when the
    // primary_key does not auto increment or is not an integer
    if ($this->entryId != -1) {
      return $this->entryId;
    } else {
      return mysql_insert_id();
    }
  }

  /**
   * Return number of rows affected
   *
   * @return int
   */
  final public function affectedRows() {
    return mysql_affectedRows();
  }

  /**
   * Returns number of rows returned
   *
   * @return int
   */
  final public function numRows() {
    if (is_resource($this->link)) {
      return mysql_numRows($this->link);
    } else {
      return 0;
    }
  }


  /**
   * Getters
   * =======================================================================
   */
  final public function getLabel() {
    return $this->label;
  }

  /**
   * Lame functions I want to remove
   * =======================================================================
   */

  /**
   * This should be a global function some day.
   *
   * @param unknown_type $date
   * @return unknown
   */
  final protected function formatDatetime($date = array()) {
    if (is_array($date)) {
      //2006-12-26 19:26:19
      $date['year']   ? true : $date['year']    = '0000';
      $date['month']  ? true : $date['month']   = '00';
      $date['day']    ? true : $date['day']     = '00';
      $date['hour']   ? true : $date['hour']    = '00';
      $date['minute'] ? true : $date['minute']  = '00';
      $date['second'] ? true : $date['second']  = '00';
      return "$date[year]-$date[month]-$date[day] $date[hour]:$date[minute]:$date[second]";
    } else {
      return $date;
    }
  }

  final protected function formatDatetimeField($field, $default) {
    if (isset($this->entry[$field])) {
      if (is_string($this->entry[$field]) && $this->entry[$field] == null) {
        $this->entry[$field] = date($default);
      } else {
        $this->entry[$field] = $this->formatDatetime($this->entry[$field]);
      }
    }
  }

  final protected function standardFieldFormats() {
    // created_on
    $this->formatDatetimeField('created_on', 'Y-m-d 00:00:00');

    // created_at
    $this->formatDatetimeField('created_at', 'Y-m-d H:i:s');

    // updated_on
    $this->formatDatetimeField('updated_on', 'Y-m-d 00:00:00');

    // updated_at
    $this->formatDatetimeField('updated_at', 'Y-m-d H:i:s');
  }

  final public function parseDbConnection($string) {
    $details = array();

    // parse connection string as url
    $parsed_string = parse_url($string);
  
    isset($parsed_string['scheme']) ? $details['driver']  = $parsed_string['scheme']  : $details['driver'] = null;
    isset($parsed_string['host'])   ? $details['host']    = $parsed_string['host']    : $details['host']   = null;
    isset($parsed_string['user'])   ? $details['user']    = $parsed_string['user']    : $details['user']   = null;
    isset($parsed_string['pass'])   ? $details['pass']    = $parsed_string['pass']    : $details['pass']   = null;
  
    parse_str($parsed_string['query'], $options);
  
    isset($options['name']) ? $details['name'] = $options['name'] : $details['name'] = null;
    isset($options['port']) ? $details['port'] = $options['port'] : $details['port'] = false;
  
    return $details;
  }

}
?>